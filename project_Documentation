now add the followers, and following list.. add the search for other accounts on a tab called explorer.. the other profile should have the follow/unfollow, message. add the website settings with all required settings to aid the user. implement allof these to be intergrated with other features.. also add the like, views, gift buttons..
 
i want to give this promt to google ai studio.. enhance it so it knows the exact steps to follow

You are an expert full-stack web developer specializing in building modern, interactive social media platforms using HTML, CSS, JavaScript, and frameworks like React.js for the frontend, Node.js/Express for the backend, and MongoDB for the database. Your goal is to generate complete, functional code for a social media website based on the following specifications. Ensure the code is modular, secure, scalable, and integrates all features seamlessly. Use best practices like responsive design, error handling, authentication, and API endpoints.

The website is a social platform where users can create profiles, post content, interact with others, and manage settings. Build upon any existing features (e.g., user profiles, posts, feeds) by adding the new ones specified. If no prior code exists, start from scratch with a basic structure.

Follow these exact steps in order to implement the enhancements:

    Set Up the Project Structure:
        Create a monorepo or separate folders for frontend (using React.js with Create React App or Vite) and backend (using Node.js/Express).
        Install necessary dependencies: For frontend - React, React Router, Axios (for API calls), Material-UI or Bootstrap for styling. For backend - Express, Mongoose (for MongoDB), JWT for authentication, CORS, bcrypt for password hashing.
        Set up a MongoDB database schema for users (with fields like username, email, password, bio, profilePic, followers: [], following: []), posts (with likes: [], views: number, gifts: []), and settings.
        Implement user authentication (signup, login, JWT-based sessions) if not already present.
    Add Followers and Following Lists:
        In the user profile page (e.g., /profile/:username), add two tabs or sections: "Followers" and "Following".
        Fetch and display lists of users who follow the current profile (from the followers array in the user model) and users the profile follows (from the following array).
        Each list item should show the user's avatar, username, and a link to their profile.
        Integrate with backend: Create API endpoints like GET /api/users/:id/followers and GET /api/users/:id/following to retrieve these lists securely (only show if public or authenticated).
        Ensure real-time updates: Use WebSockets (e.g., Socket.io) or polling to refresh lists when follow/unfollow actions occur.
    Add Search for Other Accounts on a Tab Called 'Explorer':
        Create a new main navigation tab or page called "Explorer" (e.g., route /explorer).
        Implement a search bar that queries users by username, name, or keywords (e.g., using MongoDB's text search index).
        Display search results as a grid or list of user cards, each showing avatar, username, bio snippet, follower count, and buttons for follow/unfollow and message (if applicable).
        Backend: Add API endpoint POST /api/search/users with query parameter for searching.
        Integrate with other features: Search results should link to profiles, and following a user from here updates the followers/following lists in real-time.
    Enhance Other Profiles with Follow/Unfollow and Message Buttons:
        For any user's profile page (other than the logged-in user's), add buttons: "Follow" (or "Unfollow" if already following), and "Message" (opens a chat modal or redirects to a DM page).
        Implement follow/unfollow logic: On click, send API requests to POST /api/users/:id/follow or DELETE /api/users/:id/unfollow, updating the database arrays and notifying the user (e.g., via push notifications if implemented).
        For messaging: If not already present, add a basic DM system with a chat interface. Use WebSockets for real-time messaging. API endpoints: POST /api/messages/send, GET /api/messages/:userId.
        Ensure privacy: Only allow messaging if users are mutual followers or settings permit it.
        Integrate: Following updates the lists from Step 2, and messages link to a inbox feature if exists.
    Add Website Settings with All Required Settings to Aid the User:
        Create a settings page (e.g., /settings) accessible from the user menu.
        Include sections for:
            Account: Change username, email, password, delete account.
            Profile: Edit bio, profile picture, cover photo.
            Privacy: Toggle public/private profile, who can message/follow, block users.
            Notifications: Email/push preferences for likes, follows, messages.
            Appearance: Theme (light/dark), language.
            Security: Two-factor authentication, session management.
            Data: Download data, manage connected apps.
        Use forms with validation. Backend: API endpoints like PATCH /api/users/settings for updates.
        Integrate: Settings like privacy affect visibility of followers/lists, search results, and interactions (e.g., disable follow button if private).
    Add Like, Views, and Gift Buttons to Posts:
        For each post in the feed or profile, add interactive buttons: Like (heart icon, toggles like/unlike), Views (counter that increments on view), Gift (allows sending virtual gifts, e.g., emojis or points).
        Implement logic:
            Likes: POST /api/posts/:id/like (add user to likes array), update count in real-time.
            Views: Increment on post load via POST /api/posts/:id/view (debounced to prevent spam).
            Gifts: Modal for selecting gifts (e.g., from a store), POST /api/posts/:id/gift with gift type, update gifts array or count.
        Display counts next to buttons (e.g., "5 Likes", "10 Views", "3 Gifts").
        Integrate: Likes/gifts trigger notifications to post owner. Views help in analytics or trending algorithms if implemented.
    Integrate All Features Seamlessly:
        Ensure cross-feature consistency: E.g., following a user from Explorer updates their profile's follower count and your following list.
        Use React Router for navigation between pages (home feed, profile, explorer, settings).
        Implement global state management (e.g., Redux or Context API) for user data, to keep followers/following synced across components.
        Add responsive design: Mobile-friendly layouts using CSS media queries or frameworks.
        Security: Validate all inputs, protect routes with auth middleware, handle errors gracefully.
        Testing: Include basic unit tests for key components (e.g., follow button) and API endpoints.
    Output the Complete Code:
        Provide the full codebase in a structured format: Separate sections for frontend (App.js, components, etc.), backend (server.js, routes, models), and any setup instructions (e.g., npm install, env variables for MongoDB URI, JWT secret).
        Use comments in code to explain key parts.
        If the project is too large, provide a GitHub repo structure or zipped code snippet, but aim for executable code.

Generate the code now based on these steps. If any clarification is needed, assume standard best practices.
Markdown

# NATIVCODEX_PROJECT_MANIFEST [INTERNAL_ONLY]
## VERSION: 2.1_STABLE
## LAST_SYNC: 2025-12-29

### 1. PROJECT_OVERVIEW
NativeCodeX is a sovereign gaming ecosystem designed for the technically elite. It merges high-fidelity competitive gaming with a hacker-themed administrative interface, powered by Google Gemini AI and Firebase-ready infrastructure.

### 2. CORE_MODULES (FEATURES)
- **NEXUS (Home)**: Central hub for matchmaking and system status. Features a simulated VPN-tunneled matchmaking sequence.
- **ARENA (Tournaments)**: Real-time registration system for global eSports operations.
- **STUDIO (Content Operations)**: VOD ingestion and live-streaming command center with integrated AI content gating.
- **SHADOW_MARKET (Marketplace)**: Decentralized asset exchange for cosmetics and functional HUD overlays.
- **HALL_OF_FAME (Leaderboards)**: Global operator ranking system with win-rate efficiency tracking.
- **AI_SHELL (Assistant)**: Terminal-based interface for monetization strategy, grounded in real-time Google Search data.

### 3. TECHNICAL_STACK
- **Frontend**: React 19.x (ESM modules)
- **Styling**: Tailwind CSS + Custom Cyberpunk Design System
- **Icons**: Lucide-React (Vector protocol)
- **AI Engine**: @google/genai (Gemini 3 Flash/Pro)
- **Backend Architecture**: Firebase SDK (Initialized for Auth, Firestore, and Cloud Storage)
- **State Management**: Reactive Hooks with Persistent Local Storage Bridge

### 4. AI_PROTOCOLS & SERVICES
The platform utilizes **Gemini 3 Flash Preview** across three primary vectors:

| Protocol | Service Function | Implementation |
| :--- | :--- | :--- |
| **CONTENT_GUARD** | `moderateContent` | Scans VOD titles/descriptions to enforce strictly gaming-only content. |
| **MARKET_GROUNDING** | `analyzeMonetization` | Uses `googleSearch` tool to provide live advice on gaming trends and prize pools. |
| **IDENTITY_MANIFEST** | `generateGamerArchetype` | Analyzes user interests to generate unique "Hacker Archetypes" and bios. |

### 5. BACKEND_MESH (BACKEND_SERVICE.TS)
The project implements a **High-Fidelity Firebase Simulation** that is drop-in ready for production project keys:
- **Auth Service**: Manages Google OAuth handshakes and identity session persistence via `AUTH_SESSION_KEY`.
- **Database Service**: Simulated Firestore collections for `users`, `audit_logs`, and `market_assets`.
- **Storage Service**: Asset ingestion logic with real-time progress callbacks for VOD uploads.
- **Sync Protocol**: Uses a `CloudMesh` helper to ensure data persistence across local browser nodes.

### 6. RECENT_ENHANCEMENTS
- **V2.0 Integration**: Added full Firebase SDK support and Google OAuth UI components.
- **Search Grounding**: Integrated Google Search into the AI Shell for real-world competitive intelligence.
- **Audit Logging**: Implemented a persistent "Manifest Audit Log" in the Studio to track AI moderation decisions.
- **UI Optimization**: Refactored the Layout to include a "Live Rail" for active stream nodes.

### 7. METHODS_SUMMARY
- **`syncToCloudMesh(data)`**: Core persistence method for local data synchronization.
- **`backendService.uploadAsset(file, onProgress)`**: Simulates multi-part cloud storage uploads.
- **`analyzeMonetization(query, stats)`**: Advanced AI grounding method utilizing the Gemini search tool config.
- **`moderateContent(title, desc)`**: Automated JSON-response parsing for real-time content filtering.

### 8. SECURITY_NOTICE
This manifest is a private technical document. All nodes must maintain credential isolation. Google Search Grounding is restricted to Admin-tier sessions.

 
this is what the project now has.. now re explain using this knowledge and my previuos goal
Pasted--NativeCodeX-Gaming-Platform-Product-Requirements-Document-Document-Version-1-0-Last-Upd-1751964510562_1751964510563.txt
Pasted--NativeCodeX-Gaming-Platform-Product-Requirements-Document-Document-Version-1-0-Last-Upd-1751963911198_1751963911198.txt
Pasted--DOCTYPE-html-html-lang-en-head-meta-charset-UTF-8-meta-name-viewport-content-width--1751964767460_1751964767460.txt

You are an expert full-stack web developer specializing in building modern, interactive gaming platforms using React.js for the frontend, Firebase for backend services (Auth, Firestore, Storage), Tailwind CSS for styling, and Google Gemini AI for intelligent features. Your goal is to generate complete, functional code enhancements for the NativeCodeX Gaming Platform based on the provided project manifest, product requirements document (PRD), and existing HTML landing page. Build upon the existing features (e.g., Nexus/Home, Arena/Tournaments, Studio/Content Operations, Shadow Market/Marketplace, Hall of Fame/Leaderboards, AI Shell/Assistant) by integrating new social media-style features seamlessly. Ensure the code is modular, secure, scalable, and aligns with the hacker/cyberpunk aesthetic (dark-mode-first, neon accents, Orbitron font, etc.). Use best practices like responsive design, error handling, authentication, real-time updates via Firebase listeners, and AI integration where relevant.

The platform is already set up with:

    Frontend: React 19.x, Tailwind CSS, Lucide-React icons (or Remixicon as in HTML), custom cyberpunk design system.
    Backend: Firebase SDK for Auth (Google OAuth), Firestore (collections like users, audit_logs, market_assets), Cloud Storage for assets (e.g., VODs, profiles).
    AI: Gemini 3 Flash for content moderation, monetization analysis, and archetype generation.
    Existing UI: Hacker-themed with animations, homepage with streaming highlights, profile pages (Instagram-like), in-game chat, monetary gifts, Reddit-style news feed, etc.
    Database Schema: Extend existing users collection (add fields like followers: [], following: [], posts: [] with likes: [], views: number, gifts: []).
    Other: Real-time features via Firebase, audit logging, syncToCloudMesh for persistence.

The enhancements focus on adding social features: followers/following lists, an Explorer tab for user search, follow/unfollow and message buttons on profiles, a comprehensive settings page, and like/views/gift buttons on posts (integrated with existing feeds, streams, and tournaments). Integrate these with core gaming features (e.g., follow streamers for tournament updates, like posts in game communities, gift during streams). Use Firebase for real-time sync (e.g., listeners for followers updates).

Follow these exact steps in order to implement the enhancements:

    Review and Extend Project Structure:
        Base on the existing monorepo: Frontend in src/ (App.js, components like Layout, Nexus, Arena), Backend services in backend_service.ts (with Firebase init, auth, db, storage).
        Install/update dependencies if needed: firebase, @firebase/auth, @firebase/firestore, @firebase/storage, react-router-dom, @google/generative-ai.
        Extend MongoDB simulation to full Firebase: Use Firestore for users (add followers: array of userIds, following: array of userIds), posts (in news feed or user profiles, with likes: array of userIds, views: number, gifts: array of {userId, giftType}).
        Implement auth guard: All new features require login via Google OAuth or email/password (as in PRD authentication system).
        Add real-time listeners: Use onSnapshot for followers/following updates across components.
    Add Followers and Following Lists:
        In profile pages (e.g., /profile/:username, based on existing Instagram-like profiles), add tabs/sections: "Followers" and "Following".
        Fetch lists from Firestore: users/{userId}/followers and following arrays; display as user cards (avatar, username, bio snippet, link to profile).
        Integrate with AI: Use generateGamerArchetype to suggest archetypes for listed users.
        Backend: Add Firestore rules for secure reads (only if public or followed); methods like getFollowers(userId) in backend_service.ts.
        Real-time: Use onSnapshot to update lists on follow/unfollow; integrate with notifications (e.g., "New follower" in in-game chat).
        Gaming integration: Show if followers are online/in-game (using presence from existing Discord-like features).
    Add Search for Other Accounts on a Tab Called 'Explorer':
        Add new route /explorer in React Router (add to global navigation, e.g., next to Tournaments/Streams).
        Implement search bar: Query Firestore users collection by username/bio (use text index or where clauses; for scalability, use Firebase's search limitations or integrate Gemini for semantic search).
        Display results as grid/list of user cards: Avatar, username, bio, follower count, archetype (from AI), buttons for follow/unfollow and message.
        Backend: Add searchUsers(query) in backend_service.ts using Firestore queries.
        Integration: Link results to profiles; following from here updates lists (Step 2) and triggers notifications; suggest based on user's games/tournaments (from PRD game detection).
    Enhance Other Profiles with Follow/Unfollow and Message Buttons:
        On non-logged-in-user profiles: Add "Follow"/"Unfollow" button (toggle based on if currentUser in target's followers); "Message" button (opens DM modal or routes to /messages/:userId).
        Logic: On follow, update Firestore arrays atomically (use arrayUnion/arrayRemove); notify via existing notification system.
        Messaging: Extend existing Discord-like chat: Add DM channels in Firestore (messages collection), real-time with onSnapshot; use end-to-end encryption as per PRD.
        Privacy: Check settings (Step 5) for allowFollow/allowMessages; integrate with mutual followers or game communities.
        Gaming integration: Following auto-subscribes to their streams/tournaments; messages can include game invites.
    Add Website Settings with All Required Settings to Aid the User:
        Add route /settings (accessible from user menu in nav or profile).
        Sections (forms with validation, update Firestore user doc via backend_service.updateUserSettings):
            Account: Change username/email/password, delete account (with confirmation).
            Profile: Edit bio, avatar/banner (upload to Storage), favorite games, archetype (regenerate via AI).
            Privacy: Public/private profile, who can follow/message (all/friends/none), block users (add blocks array).
            Notifications: Preferences for likes/follows/messages/gifts/tournaments (email/push/in-app).
            Appearance: Theme (dark/neon variants), language, disable animations (as per PRD accessibility).
            Security: Enable MFA, view sessions (revoke via Firebase Auth), login history.
            Data: Download data (Firestore export), manage connected apps (OAuth revokes).
            Gaming-specific: Game detection permissions, tournament visibility, monetization prefs (e.g., gift multipliers).
        Integration: Privacy affects followers visibility, search results, interactions (e.g., hide follow button if private); sync changes real-time across app.
    Add Like, Views, and Gift Buttons to Posts:
        On posts (in news feed, profiles, streams): Add buttons: Like (toggle, heart icon), Views (auto-increment on load), Gift (modal for CodeBits/virtual items, as per PRD monetary system).
        Logic: Likes: arrayUnion userId in post.likes; Views: increment post.views (debounced); Gifts: add to post.gifts array, deduct from user's CodeBits (Firestore transaction).
        Display: Counts/icons next to buttons; animated effects (neon glow on interact).
        Backend: Methods like likePost(postId), viewPost(postId), giftPost(postId, giftType) in backend_service.ts.
        Integration: Trigger notifications to post owner; likes/gifts affect trending algorithms (e.g., in homepage highlights); moderate via AI (e.g., flag suspicious activity); link to monetization (gifts payout to creators).
    Integrate All Features Seamlessly:
        Cross-feature: E.g., Follow from Explorer updates profile lists and news feed; likes on tournament posts notify participants; gifts during streams use existing animations.
        Use React Context/Redux for global state (user data, real-time followers); Router for nav (add Explorer/Settings to menu).
        AI enhancements: Use moderateContent on posts/messages; analyzeMonetization for gift suggestions; generateArchetype on profile edits.
        Responsive: Tailwind media queries; mobile-friendly (as per PRD mobile optimization).
        Security: Firebase rules (e.g., authenticated writes); error handling (toasts); audit logs for actions (extend existing).
        Gaming tie-ins: Followers see your tournament stats; search filters by games; settings control in-game notifications.
        Testing: Add unit tests for buttons (e.g., follow toggle), API methods; simulate Firebase with emulators.
    Output the Complete Code Enhancements:
        Provide diffs or full files: Update App.js (routes), add components (Explorer.js, Settings.js, FollowList.js, etc.), extend backend_service.ts.
        Update HTML landing page to include new nav links (Explorer, Settings).
        Include setup: Firebase config env vars (API_KEY, etc.); npm scripts for build/deploy.
        If large, structure as: Frontend updates, Backend extensions, Firebase rules/schema.

Generate the code now based on these steps. Assume standard best practices for any gaps, aligning with the PRD (e.g., scalability targets, security).

now what am i missing in the project

Based on the provided project manifest (version 2.1_STABLE, last synced December 29, 2025), the HTML landing page prototype, and the Product Requirements Document (PRD version 1.0, last updated July 8, 2025), along with the recent enhancements for social features (followers/following, Explorer tab, profile buttons, settings, and post interactions), I've analyzed what's implemented versus the full vision. The current date (December 30, 2025) places the project roughly at the end of Phase 2 in the PRD's implementation roadmap (Months 4-6: Core Experience, assuming a start around July 2025).

This analysis maps the PRD's requirements to the manifest's core modules, AI protocols, backend services, recent enhancements, and the landing page. I'll highlight what's covered (fully or partially), what's missing (key gaps in features, technical aspects, and other PRD sections), and recommendations for next steps. Gaps are prioritized by PRD's "MUST" requirements first, as they're mandatory. Note that the manifest focuses on high-level modules and tech stack, so many specifics (e.g., UI details) may be implicitly covered but not explicitly documented—I've erred on the side of calling them "missing" if not mentioned.
1. Feature Coverage (from PRD Section 3: Feature Specifications)

The PRD outlines 7 core components and 13+ detailed features. The manifest covers ~50-60% at a high level, with enhancements adding social/gaming integrations. Here's a breakdown:
Covered or Partially Implemented:

    Hacker-Themed UI/UX with Animations: Partially covered via Tailwind CSS + Custom Cyberpunk Design System, Lucide-React icons, and UI Optimization (e.g., "Live Rail" for streams). The landing page demonstrates neon accents, dark mode, Orbitron font, and subtle effects. However, specific MUSTs like glitch/holographic elements, particle effects, and easter eggs are not mentioned.
    Homepage with Twitch-like Streaming Highlights: Covered by NEXUS (Home) module and landing page (grid of streams, viewer counts, navigation). Real-time updates and personalization align with Firebase listeners.
    Tournament System with Game Installation Detection: Covered by ARENA (Tournaments) for registration and operations. Partial integration with game detection (mentioned in PRD but not in manifest—could tie into backend storage/services).
    Authentication System: Covered by Backend Auth Service (Google OAuth, session persistence). Supports social logins (e.g., Google), but MUSTs like MFA (SMS/app-based), email/password, and recovery options are partially addressed (Firebase handles some natively).
    Instagram-like Profile Pages: Enhanced with followers/following, archetypes (via AI IDENTITY_MANIFEST), stats (ties to HALL_OF_FAME). Landing page has basic profile elements; enhancements add customization and privacy.
    In-game Chat and Notifications Integration: Partially via enhancements (messages, presence from Discord-like features) and notifications (tied to follows/likes). Overlay and in-game visibility not explicitly mentioned.
    Monetary Gift System: Enhanced with gift buttons; ties to AI MARKET_GROUNDING for analysis. CodeBits and animations align, but leaderboards/recurring gifts are partial.
    Reddit-style Game News Feed: Partially via post enhancements (likes, views, upvotes/downvotes implied). Content types and moderation (via CONTENT_GUARD) covered.
    Player Statistics Dashboards: Covered by HALL_OF_FAME (rankings, win-rates) with visualizations and comparisons.
    Discord-like Friends, Groups, and Channels: Enhanced with friends (followers, messages); groups partial via communities. Text/voice channels and permissions not fully detailed.
    Gaming Store for In-game Purchases: Covered by SHADOW_MARKET (asset exchange, cosmetics). Purchase history and recommendations partial.
    Game-Specific Community Groups: Partially via news feed and social enhancements; LFG (looking-for-group) ties to tournaments.
    Platform Customization (Themes, etc.): Partially via settings enhancements (appearance, accessibility); custom themes for premiums mentioned in PRD profiles.

Missing Features (Key Gaps):

These are PRD MUST/SHOULD requirements not explicitly in the manifest, enhancements, or landing page. I've focused on high-impact ones; see tool output for full list of unmatched MUSTs.

    Game Installation Detection and Integration: MUST detect installed games (with permission) and integrate with APIs for auto-results/pulling stats. Not in manifest (though backend could extend for this). Critical for seamless tournaments and stats dashboards—current ARENA lacks this.
    Advanced Tournament Features: MUSTs like bracket generation, match verification (e.g., screenshot/replay parsing), team management, and scheduling with time zones. ARENA covers basics, but no seeding, streaming overlays, or anti-cheat (from PRD security).
    In-Game Overlays and Notifications: MUST provide chat/notifications during gameplay (low-resource). Presence indicators covered partially, but full overlay tech (compatible with game engines) missing.
    Voice/Video Communication: MUST support voice channels (quality options); SHOULD include video calls/screen sharing. Discord-like module mentions friends/groups but not voice infrastructure (low-latency required).
    Full Streaming Infrastructure: Homepage/STUDIO cover highlights/VOD, but missing low-latency modes (<2s), multi-platform integration (OBS/Streamlabs), and auto-overlays for tournaments.
    Content Discovery and Recommendations: MUST personalize based on history (homepage partial); SHOULD include trending clips/topics. No full search/recommendation engine beyond Explorer.
    Developer Tools and APIs: For game devs (e.g., community creation, analytics). Tertiary audience in PRD, but no module for this.
    Anti-Cheat and Fraud Prevention: From PRD security: MUST include measures for tournaments (e.g., screenshot verification, bot detection). Not in manifest.
    Mobile Optimization and Apps: PRD Phase 4 and post-launch Q1: Responsive design partial (Tailwind), but no native iOS/Android apps or PWA capabilities.
    Internationalization/Localization: Post-launch Q4: No mention of language support, regional features, or time zone handling beyond tournaments.
    Accessibility Options: SHOULD/MUST disable animations, high-contrast themes, reduced motion. Settings enhancements cover some, but not fully.

2. Other PRD Sections: Coverage and Gaps

    User Personas and Flows (Section 2 & 4): Partially addressed via archetypes (AI) and social/tournament features. Missing detailed journey maps (e.g., competitive gamer flow for skill matching) and pain point resolutions (e.g., fragmented social experiences).
    Monetization Strategy (Section 5): AI_SHELL analyzes trends/prizes, but missing implementation: Subscriptions (tiers), ads (non-intrusive), creator payouts (25% fee), CodeBits economy, transactions (PCI compliance). No bundle deals or B2B (e.g., for publishers).
    Technical Requirements (Section 6): Stack matches (React, Firebase), but missing scalability targets (e.g., 100K concurrent users, <100ms API), latency (<5s streams), compatibility (desktop apps for Windows/macOS/Linux), third-party integrations (payment: Stripe/PayPal; game libs: Steam/Epic).
    Security and Privacy (Section 7): Partial via Firebase rules, E2E encryption (chat), audit logs. Missing MFA enforcement, fraud monitoring (anti-cheat), compliance (GDPR/CCPA/COPPA), content moderation (AI + human 24/7), data retention policies.
    Implementation Roadmap (Section 8): At Dec 30, 2025 (~Month 6), Phase 1 (foundation) and Phase 2 (streaming/communities/game integration) should be complete. Missing: Phase 3 (monetization, premium features, basic tournaments) and Phase 4 (advanced tournaments, enhanced streaming, full launch). Post-launch (Year 2: 2026) entirely absent (mobile apps, analytics, developer API, expansion).
    Competitive Analysis (Section 9): No integration (e.g., tools to monitor competitors like Twitch/Discord). SWOT opportunities (e.g., partnerships) unaddressed.
    Metrics and Success Criteria (Section 10): No tracking for KPIs (e.g., MAU/DAU, engagement, revenue). Missing dashboards for uptime, moderation speed, surveys.
    Open Questions (Section 11): All 15+ unresolved (e.g., publisher partnerships, mobile strategy, anti-cheat methods, advertising). These should guide next iterations.

3. Overall Project Health and Recommendations

    Progress: Strong foundation in core gaming/social features (60-70% of PRD features partially covered). Firebase/AI integration positions well for scalability/security. Landing page is a good MVP for user acquisition.
    Risks: Over-reliance on Firebase simulation (needs real prod keys). No mobile focus yet (PRD emphasizes desktop first, but mobile web browsers supported). Date suggests pre-beta (limited public beta in Phase 2), so user testing/metrics absent.
    Next Steps:
        Implement Phase 3 Priorities: Focus on monetization (CodeBits, payouts) and advanced tournaments (detection, anti-cheat) to hit Q1 2026 milestones (>50K users).
        Address MUST Gaps: Prioritize game detection (filesystem monitoring with permissions) and overlays (use Electron for desktop app?).
        Enhance with Tools: Use AI_SHELL to ground monetization; extend CONTENT_GUARD for all uploads/posts.
        Roadmap Alignment: Plan public beta release (Phase 3) with influencer partnerships. Resolve open questions (e.g., via team discussions or external research).
        Testing/Metrics: Add analytics (Google Analytics/Mixpanel as per PRD) and unit tests for new enhancements.
        If Needed: Update PRD to v1.1 reflecting enhancements; consider web search for competitor updates (e.g., Twitch features in late 2025).

If this doesn't cover a specific aspect you're thinking of, provide more details on what "project" scope you mean (e.g., code vs. business).
Executed code

now give me a fully made prompt for creating the admin dashboard with all the features and funtions for the admin for the full website.. it will only be visible if the account sheldonramu8@gmail.com logins in.

You are an expert full-stack web developer specializing in building secure, scalable admin dashboards for modern gaming platforms using React.js for the frontend, Firebase for backend services (Auth, Firestore, Storage, Functions), Tailwind CSS for styling, and Google Gemini AI for intelligent moderation and analytics. Your goal is to generate complete, functional code for an Admin Dashboard in the NativeCodeX Gaming Platform, based on the provided Product Requirements Document (PRD), project manifest, and existing features (e.g., user profiles, tournaments, streams, news feeds, marketplace, AI shell). The dashboard must align with the hacker/cyberpunk aesthetic (dark-mode-first, neon green accents, Orbitron font, glitch animations, terminal-inspired elements) and be fully integrated with the existing app. Ensure the code is modular, responsive, secure (role-based access), and uses best practices like real-time updates (Firestore listeners), error handling, pagination for large data sets, and AI integration for moderation.

The Admin Dashboard should only be visible and accessible if the logged-in user has the email "sheldonramu8@gmail.com" (implement as a super-admin role in Firebase Auth custom claims or Firestore user doc). For all other users, redirect to the home page or show a 403 error. Use Firebase Authentication to enforce this, and add audit logging for all admin actions (extend existing audit_logs collection).

Follow these exact steps to implement the Admin Dashboard:

    Set Up the Dashboard Structure:
        Add a new route /admin in React Router (protected route, accessible from a hidden nav item or direct URL only for the super-admin).
        Use a sidebar layout: Left sidebar with navigation tabs (e.g., Dashboard Overview, Users, Moderation, Tournaments, Streams, Monetization, Analytics, Security, Settings), main content area for selected tab, top header with search bar, logout, and platform stats (e.g., online users, active streams).
        Install/update dependencies if needed: firebase, react-router-dom, @heroicons/react (for icons, or use Remixicon as in landing page), recharts (for charts in analytics), @google/generative-ai (for AI moderation).
        Extend Firebase: Add admin collection in Firestore for configs; use Cloud Functions for server-side actions (e.g., bulk user bans, payout processing) to ensure security.
        Authentication Guard: In the Admin route component, use Firebase onAuthStateChanged to check if currentUser.email === "sheldonramu8@gmail.com"; if not, redirect to /home. Set custom claim 'isSuperAdmin: true' via Firebase Admin SDK (assume setup in backend_service.ts).
    Implement Dashboard Overview:
        A landing tab with key metrics: Cards for MAU/DAU (from PRD metrics), revenue overview, active tournaments/streams, pending moderation reports, system health (uptime, latency from PRD tech reqs).
        Use Recharts for visualizations: Line chart for user growth, pie chart for revenue sources (subscriptions, gifts, ads).
        Real-time: Use onSnapshot listeners on relevant collections (e.g., users, transactions) to update stats live.
        Integrate AI: Button to "Analyze Platform Health" using Gemini to generate insights (e.g., call analyzeMonetization with current stats).
    User Management Features:
        Table view of all users (from users collection): Columns for username, email, join date, role (user/creator/mod/admin), status (active/banned), follower count, archetype.
        Search/filter by username/email/role; pagination (e.g., 50 per page).
        Actions per user: View/edit profile (bio, avatar, stats), assign roles, ban/suspend (update status field, log action), reset password (via Firebase Auth), view activity log (posts, follows, gifts).
        Bulk actions: Select multiple users for ban/export.
        Gaming integration: View user's tournament history, stats dashboards; flag cheaters (tie to anti-cheat from PRD).
    Content Moderation Features:
        Queue of reported content: Tabs for posts (news feed), streams/VODs, messages/chats, profiles.
        For each item: View content/details, AI analysis (call moderateContent with title/desc to get violation scores/reasons), human decision (approve/remove/ban user).
        Tools: Search reports by user/type/date; auto-filter with AI (e.g., text/image filtering as per PRD); escalation to human mod team (simulate with notes).
        Stats: Moderation speed, resolution rates (track for PRD metrics).
        Integration: Tie to existing CONTENT_GUARD; log all decisions in audit_logs.
    Tournament Management Features:
        List of all tournaments: Create new (formats: elimination/round-robin, set prizes, schedules, game integration).
        For each: Edit details, view participants/teams, verify results (manual or API pull), distribute prizes (via CodeBits/transactions).
        Tools: Seeding based on stats, anti-cheat review (screenshots/replays from Storage), streaming integration (auto-overlays).
        Analytics: Participation rates, completion stats.
        Real-time: Monitor ongoing tournaments with live brackets/updates.
    Streams and Community Management Features:
        Monitor live streams: List with viewer counts, take down violations, view chat logs.
        Community groups/channels: Create/edit game-specific groups, manage roles/permissions (extend Discord-like features).
        VOD review: Moderate uploaded content, analytics on viewership.
        Integration: Tie to gift system (view transactions), news feed (promote trending).
    Monetization and Marketplace Features:
        Manage CodeBits economy: Set exchange rates, view balances, process payouts (comply with tax regs via Stripe integration as per PRD).
        Marketplace oversight: Approve items, view transactions, handle disputes.
        Revenue dashboards: Breakdown by source (gifts, subs, ads), set platform fees (25% as per competitive analysis).
        AI: Use MARKET_GROUNDING to suggest optimizations (e.g., gift multipliers for events).
    Analytics and Metrics Features:
        Comprehensive dashboards: User acquisition/retention (charts for MAU/DAU, churn), engagement (interactions, tournament participation), monetization (ARPU, conversions), platform health (uptime, latency, error rates).
        Custom reports: Filter by date/region/game; export CSV/PDF.
        Integrate with PRD KPIs: Track success milestones (e.g., >1M MAU by EOY).
        AI-powered insights: Generate suggestions for improvement (e.g., via Gemini on trends).
    Security and Privacy Features:
        View login history, active sessions (revoke via Firebase), IP logs.
        Manage compliance: GDPR requests (data download/delete), age verification.
        Fraud detection: Monitor for bots/cheats, view transaction anomalies.
        Content retention policies: Set auto-deletion for data (as per PRD).
        Vulnerability reports: Form for logging issues.
    Platform Settings and Customization:
        Global configs: Themes (neon variants), maintenance mode, API keys (for integrations like Stripe, game APIs).
        Feature toggles: Enable/disable new features (e.g., low-latency streaming).
        Backup/restore: Tools for data export/import.
        Developer tools: API docs, test environments.
    Integrate All Features Seamlessly:
        Use React Context for admin state; real-time updates with Firestore listeners.
        Security: All actions require auth; use transactions for critical ops (e.g., bans).
        UI: Hacker theme with animations (glitch on load), responsive (mobile-friendly), accessibility (disable animations option).
        Testing: Add unit tests for components (e.g., user table), e2e for flows (e.g., ban user).
        Extend backend_service.ts: Add admin methods (e.g., banUser(userId), getReports()).
        Firebase Rules: Restrict admin reads/writes to super-admin.
    Output the Complete Code:
        Provide full files: AdminDashboard.js (main component), sub-components (e.g., UserTable.js, ModerationQueue.js), updates to App.js (add route), backend_service.ts extensions, Firebase Cloud Functions if needed.
        Include setup: Env vars for Firebase, scripts for deploy.
        If large, structure as folder tree with code snippets.

Generate the code now based on these steps. Assume best practices for gaps, ensuring compliance with PRD (e.g., scalability, security).
